{
  "start": {
    "title": "Find or Fix",
    "description": "Due to some previous actions you may have lost some work which you'd like to find and restore, or, maybe you have made some changes which you'd like to fix. Fixing includes updating, rewording, and deleting.",
    "links": [
      { "path": "/committedp", "text": "Fix a change" },
      {
        "path": "/lostnfound",
        "text": "Find what is lost"
      }
    ]
  },
  "committedp": {
    "title": "Have you committed?",
    "description": "If you have not yet committed that which you do not want, git does not know anything about what you have done yet, so it is pretty easy to undo what you have done.",
    "links": [
      {
        "path": "/committed",
        "text": "Yes, commits were made"
      },
      { "path": "/uncommitted", "text": "No, I've not yet committed" },
      { "path": "/badmerge", "text": "Help! I'm in the middle of a bad merge" },
      { "path": "/badrebase", "text": "Help! I'm in the middle of a bad rebase" }
    ]
  },
  "committed": {
    "title": "Do you have uncommitted stuff in your working directory?",
    "description": "So you have committed. However, before we go about fixing or removing whatever is wrong, you should first ensure that any uncommitted changes are safe, by either committing them (<code className=\"bg-gray-200 text-red-800 p-1 text-sm\">git commit</code>) or by stashing them (<code className=\"bg-gray-200 text-red-800 p-1 text-sm\">git stash save 'message'</code>) or getting rid of them.<br/><code className=\"bg-gray-200 text-red-800 p-1 text-sm\">git status</code> will help you understand whether your working directory is clean or not. It should report nothing for perfect safety ('Untracked files' only are sometimes safe.)",
    "links": [
      {
        "path": "/committed_really",
        "text": "No, I have no changes/working directory is clean"
      },
      {
        "path": "/uncommitted_everything",
        "text": "Yes, I have bad changes/working directory is dirty: discard it"
      },
      {
        "path": "/uncommitted_commit",
        "text": "Yes, I have good changes/working directory is dirty: save it"
      }
    ]
  },
  "uncommitted": {
    "title": "Discard everything or just some things?",
    "description": "So you have not yet committed, the question is now whether you want to undo everything which you have done since the last commit or just some things, or just save what you have done?",
    "links": [
      {
        "path": "/uncommitted_everything",
        "text": "Discard everything"
      },
      {
        "path": "/uncommitted_somethings",
        "text": "Discard some things"
      },
      {
        "path": "/uncommitted_commit",
        "text": "I want to save my changes"
      }
    ]
  },
  "committed_really": {
    "title": "Have you pushed?",
    "description": "So you have committed, the question is now whether you have made your changes (or at least the changes you are interesting in 'fixing') publicly available or not. Publishing history is a seminal event.<p>If you are dealing with commits someone else made, then this question covers whether they have pushed, and since you have their commits, the answer is almost certainly 'yes'.</p><p>Please note in any and all events, the recipes provided here will typically (only one exception which will self-notify) only modify the current branch you are on. Specifically any tags or branches involving the commit you are changing or a child of that commit will not be modified. You must deal with those separately. Look at <code className=\"bg-gray-200 text-red-800 p-1 text-sm\">gitk --all --date-order</code> to help visualize everything what other git references might need to be updated.</p><p>Also note that these commands will fix up the referenced commits in your repository. There will be reflog'd and dangling commits holding the state you just corrected. This is normally a good thing and it will eventually go away by itself, but if for some reason you want to cut your seat belts, you can expire the reflog now and garbage collect with immediate pruning.</p>",
    "links": [
      {
        "path": "/pushed",
        "text": "Yes, pushes were made"
      },
      {
        "path": "/unpushed",
        "text": "No pushes"
      }
    ]
  },
  "pushed": {
    "title": "Can you make a positive commit to fix the problem and what is the fix class?",
    "description": "<a href=\"https://sethrobertson.github.io/GitBestPractices/#pubonce\" target=\"_blank\">Rewriting public history</a> is a bad idea. It requires everyone else to do special things and you must publicly announce your failure. Ideally you will create either a commit to just fix the problem, or a new <code className=\"bg-gray-200 text-red-800 p-1 text-sm\">git revert</code> commit to create a new commit which undoes what the commit target of the revert did.",
    "links": [
      {
        "path": "/pushed_restore_file",
        "text": "Yes, I can make a new commit but the bad commit trashed a particular file in error (among other good things I want to keep)"
      },
      {
        "path": "/pushed_new_merge",
        "text": "Yes, I can make a new commit and the bad commit is a merge commit I want to totally remove"
      },
      {
        "path": "/pushed_new_simple",
        "text": "Yes, I can make a new commit but the bad commit is a simple commit I want to totally remove"
      },
      {
        "path": "/pushed_fixit",
        "text": "Yes, I can make a new commit and the bad commit has an error in it I want to fix"
      },
      {
        "path": "/branch_overlay_merge",
        "text": "Yes, I can make a new commit but history is all messed up and I have a replacement branch"
      },
      {
        "path": "/pushed_old",
        "text": "No, I am a bad person and must rewrite published history"
      }
    ]
  },
  "unpushed": {
    "title": "Do you want to discard all unpushed changes on this branch?",
    "description": "There is a shortcut in case you want to discard all changes made on this branch since you have last pushed or in any event, to make your local branch identical to 'upstream'. Upstream, for local tracking branches, is the place you get history from when you <code className=\"bg-gray-200 text-red-800 p-1 text-sm\">git pull</code>: typically for master it might be origin/master. There is a variant of this option which lets you make your local branch identical to some other branch or ref.",
    "links": [
      {
        "path": "/discard_all_unpushed",
        "text": "Yes, I want to discard all unpushed changes"
      },
      {
        "path": "/replace_all_unpushed",
        "text": "Yes, and I want to make my branch identical to some non-upstream ref"
      },
      {
        "path": "/fix_unpushed",
        "text": "No, I want to fix some unpushed changes"
      }
    ]
  },
  "fix_unpushed": {
    "title": "Is the commit you want to fix the most recent?",
    "description": "While the techniques mentioned to deal with deeper commits will work on the most recent, there are some convenient shortcuts you can take with the most recent commit.",
    "links": [
      {
        "path": "/change_last",
        "text": "Yes, I want to change the most recent commit"
      },
      {
        "path": "/remove_last",
        "text": "Yes, I want to discard the most recent commit(s)"
      },
      {
        "path": "/undo_tip",
        "text": "Yes, I want to undo the last git operation(s) affecting the HEAD/tip of my branch (most useful for rebase, reset, or --amend)"
      },
      {
        "path": "/change_deep",
        "text": "No, I want to change an older commit"
      },
      {
        "path": "/pushed_restore_file",
        "text": "No, I want to restore a older version of/deleted file as a new commit"
      },
      {
        "path": "/move_commit",
        "text": "Either way, I want to move a commit from one branch to another"
      }
    ]
  },
  "change_last": {
    "title": "Do you want to remove or change the commit message/contents of the last commit?",
    "description": "",
    "links": [
      {
        "path": "/remove_last",
        "text": "I want to remove the last commit"
      },
      {
        "path": "/update_last",
        "text": "I want to update the author/message/contents of the last commit"
      },
      {
        "path": "/rework_last",
        "text": "I want to reorder, split, merge, or significantly rework the last commit(s)"
      }
    ]
  },
  "change_deep": {
    "title": "Do you want to remove an entire commit?",
    "description": "",
    "links": [
      {
        "path": "/remove_deep",
        "text": "Yes, I want to remove an entire commit"
      },
      {
        "path": "/modify_deep",
        "text": "No, I want to change an older commit"
      }
    ]
  },
  "modify_deep": {
    "title": "Do you want to remove/change/rename a particular file/directory from all commits during all of git's history",
    "description": "",
    "links": [
      {
        "path": "/bulk_rewrite_history",
        "text": "Yes please, I want to make a change involving all git commits"
      },
      {
        "path": "/change_single_deep",
        "text": "No, I only want to change a single commit"
      }
    ]
  },
  "bulk_rewrite_history": {
    "title": "Changing all commits during all of git's history",
    "description": "You have not pushed but still somehow want to change all commits in all of git's history? Strange.",
    "links": [
      {
        "path": "/filterbranch",
        "text": "Not just removing data (eg. re-arranging directory structure for all commits), or just wanting to use standard tools"
      },
      {
        "path": "/bfg",
        "text": "Want to only remove unwanted data (big files, private data, etc) and am willing to use a third party tool to do the job more quickly"
      }
    ]
  },
  "change_single_deep": {
    "title": "Is a merge commit involved?",
    "description": "If the commit you are trying to change is a merge commit, or if there is a merge commit between the commit you are trying to change and the tip of the branch you are on, then you need to do some special handling of the situation.",
    "links": [
      {
        "path": "/change_single_deep_merge",
        "text": "Yes, a merge commit is involved"
      },
      {
        "path": "/change_single_deep_simple",
        "text": "No, only simple commits"
      }
    ]
  }
}
